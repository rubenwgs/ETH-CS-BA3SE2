\documentclass[a4paper]{extarticle}
\usepackage[utf8]{inputenc}
\usepackage[a4paper, margin=1in]{geometry}

\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{enumitem}
\usepackage{tcolorbox}
\usepackage{fancyhdr}
\usepackage{graphicx}
\usepackage{float}

\setlength{\parindent}{0em}
\setlength{\parskip}{0.4em}

\definecolor{theoremblue}{RGB}{1, 73, 124}
\definecolor{corollaryblue}{RGB}{70, 143, 175}
\definecolor{exampleblue}{RGB}{137, 194, 217}

\newtcolorbox{tbox}{colback=theoremblue!20,colframe=theoremblue,
boxrule=0pt,arc=0pt,boxsep=2pt,left=2pt,right=2pt,leftrule=2pt}

\newtcolorbox{cbox}{colback=corollaryblue!20,colframe=corollaryblue,
boxrule=0pt,arc=0pt,boxsep=2pt,left=2pt,right=2pt,leftrule=2pt}

\newtcolorbox{ebox}{colback=exampleblue!20,colframe=exampleblue,
boxrule=0pt,arc=0pt,boxsep=2pt,left=2pt,right=2pt,leftrule=2pt}

\title{FMFP - Lecture Notes Week 3}
\author{Ruben Schenk, ruben.schenk@inf.ethz.ch}
\date{\today}

\pagestyle{fancy}
\fancyhf{}
\rhead{ruben.schenk@inf.ethz.ch}
\rfoot{Page \thepage}
\lhead{FMFP - Lecture Notes Week 3}

\begin{document}

\maketitle
\newpage

\subsubsection{Patterns}

\textbf{Pattern matching} has two main purposes:

\begin{itemize}
    \item checks if an argument has the proper form
    \item binds values to variables
\end{itemize}

\begin{ebox}
    \textbf{Example:} \verb|(x : xs)| matches with \verb|[2, 3, 4]| and binds:
    \begin{verbatim}
        x  = 2
        xs = [3, 4]
    \end{verbatim}
\end{ebox}

Patterns are \textit{inductively} defined:

\begin{itemize}
    \item Constants: \verb|-2, '1', True, []|
    \item Variables: \verb|x, foo|
    \item Wild card: \verb|_|
    \item Tuples: \verb|(p1, p2,..., pk)|, where \verb|p_i| are patterns
    \item Non-empty list: \verb|(p1 : p2)|, where \verb|p_i| are patterns
\end{itemize}

Moreover, patterns require to be \textbf{linear}, this means that each variable can occur at most once.

\subsubsection{Advice on Recursion}

Defining a recursion is best done by obeying the following simple steps:

\begin{itemize}
    \item Step 1: Define the type of the function
    \item Step 2: Enumerate all different cases
    \item Step 3: Define the most simple cases
    \item Step 4: Define the remaining cases
    \item Step 5: Generalize and simplify
\end{itemize}

\begin{ebox}
    \textbf{Example:} The following code snippet shows an example of how we implement \textit{insertion sort} recursively in Haskell:

    \begin{verbatim}
        isort :: [Int] -> Int
        isort []       = []
        isort (x : xs) = ins x (isort xs)

        ins :: Int -> [Int] -> [Int]
        ins a [] = [a]
        ins a (x : xs)
          | a >= x    = a : (x : xs)
          | otherwise = x : ins a xs
    \end{verbatim}
\end{ebox}

\begin{ebox}
    \textbf{Example:} The following code snippet shows how we can implement \textit{quicksort} recursively in Haskell:

    \begin{verbatim}
        qsort [] = []
        qsort (x : xs) =
          qsort (lesseq x xs) ++ [x] ++ qsort (greater x xs)
          where
            lesseq _ [] = []
            lesseq x (y : ys)
              | (y <= x)  = y : lesseq x ys
              | otheriwse =     lesseq x ys
            greater _ [] = []
            greater x (y : ys)
              | (y > x)   = y : greater x ys
              | otherwise =     greater x ys
    \end{verbatim}
\end{ebox}

\subsubsection{List Comprehensions}

\textbf{List comprehension} is a notation for sequential processing of list elements. It is analogous to set comprehension in set theory, i.e. \(\{2 \cdot x \, | \, x \in X\}\). In Haskell, this is equivalent to \([2 * x \, | \, x \leftarrow xs]\).

List comprehensions are very powerful! The following code snippet, again, implements \textit{quicksort} as shown previously:

\begin{verbatim}
    q []       = []
    q (p : xs) = q [x | x <- xs, x <= p] ++ [p] ++ q [x | x <- xs, x > p]
\end{verbatim}

\subsubsection{Induction over Lists}

How are elements in \verb|[T]| constructed? \verb|[] :: [T]| and \verb|(y : ys) :: [T]| if \verb|y :: T| and \verb|ys :: [T]|. This corresponds to the following rule:

\begin{itemize}
    \item Proof by induction: to prove \(P\) for all \verb|xs| in \verb|[T]|
    \item Base case: prove \(P[xs \to []]\)
    \item Step case: prove \(\forall y :: T, \, ys :: [T].P[xs \to ys] \to P[xs \to y : ys]\), i.e.
    \begin{itemize}
        \item Fix arbitrary: \(y :: T\) and \(ys :: [T]\) (both not free in \(P\))
        \item Induction hypothesis: \(P[xs \to ys]\)
        \item To prove: \(P[xs \to y : ys]\)
    \end{itemize}
\end{itemize}

\subsection{Abstractions}

\subsubsection{Polymorhpic Types}

If we consider the \verb|length| function, it should output the length of a list of \textit{any} type. We say that the type of the function is \textbf{polymorphic,} i.e. \verb|[t] -> Int| for all types \(t\).

This is often called \textbf{parametric polymorphism,} which is different from \textit{subtyping polymorphism,} where methods can be applied to objects of sub-classes only.

\textbf{Definition:} A type \(w\) for \(f\) is a \textbf{most general} (also called \textbf{principal}) type iff. for all types \(s\) for \(f\), \(s\) is an instance of \(w\).

It is important to note that type variables in Haskell start with a \textit{lower-case letter!}

\begin{ebox}
    \textbf{Example:} Consider the following polymorphic types:
    \begin{verbatim}
        :type (++)
        (++) :: [a] -> [a] -> [a]

        :type zip
        zip :: [a] -> [b] -> [(a, b)]

        :type []
        [] :: [a]
    \end{verbatim}
\end{ebox}

\subsubsection{Higher-order Functions}

We can distinguish the order of functions in the following way:

\begin{itemize}
    \item First order: Arguments are base types or constructor types \begin{verbatim}
        Int -> [Int]
    \end{verbatim}
    \item Second order: Arguments are themselves functions \begin{verbatim}
        (Int -> Int) -> [Int]
    \end{verbatim}
    \item Third order: Arguments are functions, whose arguments are functions \begin{verbatim}
        ((Int -> Int) -> Int) -> [Int]
    \end{verbatim}
    \item Higher-order functions: Functions of arbitrary order
\end{itemize}

\begin{ebox}
    \textbf{Example:} Consider the \verb|map| function:
    \begin{verbatim}
        map :: (a -> b) -> [a] -> [b]
        map f []       = []
        map f (x : xs) = f x : map f xs

        times2 x = 2 * x

        double xs = map times2 xs
    \end{verbatim}
\end{ebox}

\begin{ebox}
    \textbf{Example:} Consider the \verb|foldr| function:
    \begin{verbatim}
        foldr :: (a -> b -> b) -> b -> [a] -> b
        foldr f z []       = z
        foldr f z (x : xs) = f x (foldr f z xs)

        sumList xs = foldr (+) 0 xs
    \end{verbatim}
\end{ebox}

\subsubsection{\(\lambda\)-Expressions}

Consider the following two functions:
\begin{verbatim}
    times2 x = 2 * x
    double xs = map times2 xs

    atEnd x xs = xs ++ [x]
    rev xs = foldr atEnd [] xs
\end{verbatim}

Haskell provides a notation to write functions like \verb|times2| and \verb|atEnd| in-line via so-called \textbf{\(\lambda\)-expressions:}
\begin{verbatim}
    ? map (\x -> 2 * x) [2, 3, 4]
    [4, 6, 8]

    ? foldr (\x xs -> xs ++ [x]) [] [1, 2, 3, 4]
    [4, 3, 2, 1]
\end{verbatim}

This is also called \textit{Church's \(\lambda\)-notation,} i.e. replacing \(\lambda\) by the character \verb|'\'|.

\subsubsection{Functions as Values}

In Haskell, functions can be returned as values! Consider the following simple example where we return the two-times-application of some function \(f\):
\begin{verbatim}
    (.) :: (b -> c) -> (a -> b) -> (a -> c)
    (f . g) x = f (g x)

    twice :: (t -> t) -> (t -> t)
    twice f = f . f

    ? twice times2 3
    12 :: Int
\end{verbatim}

\subsubsection{Differece Lists}

\textbf{Difference lists} are functions \verb|[a] -> [a]| that prepend a list to its argument.
\begin{verbatim}
    type DList a = [a] -> [a]

    empty :: DList a
    empty = \xs -> xs                      -- empty list

    sngl :: a -> DList a
    sngl x = \xs -> x : xs                 -- singleton list

    app :: DList a -> DList a -> DList a
    ys 'app' zs = \xs -> ys (zs xs)        -- concatenation

    fromList :: [a] -> DList a
    fromList ys = \xs -> ys ++ xs          -- conversion from lists

    toList :: DList a -> [a]
    toList ys = ys []                      -- conversion to lists
\end{verbatim}

\end{document}
